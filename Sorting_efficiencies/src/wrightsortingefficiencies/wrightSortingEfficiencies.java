/*
 * Silas Wright
 * wright Sorting Efficiencies
 * January 12 2022


Purpose: Compares efficiancies of different sorting methods when factors such as file size and sorting order change
This class provides a user friendly GUI which will be able to read from data files and sort integers
 */
package wrightsortingefficiencies;

import java.io.File;
import java.io.FileNotFoundException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 * @author Silas Wright
 */
public class wrightSortingEfficiencies extends javax.swing.JFrame {

    /**
     * Creates new form wrightSortingEfficiencies
     */
    public wrightSortingEfficiencies() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnGOrder = new javax.swing.ButtonGroup();
        btnGNumber = new javax.swing.ButtonGroup();
        jpBackground = new javax.swing.JPanel();
        jlblHeader = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jrbTen = new javax.swing.JRadioButton();
        jrbTenThousand = new javax.swing.JRadioButton();
        jlblSortingMethod = new javax.swing.JLabel();
        jcbSortingMethod = new javax.swing.JComboBox<>();
        jlblSortOrder = new javax.swing.JLabel();
        jrbAscending = new javax.swing.JRadioButton();
        jrbDescending = new javax.swing.JRadioButton();
        jbSort = new javax.swing.JButton();
        jlblOriginal = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jtaOriginal = new javax.swing.JTextArea();
        jlblSorted = new javax.swing.JLabel();
        jlblResults = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jtaResults = new javax.swing.JTextArea();
        jtaSorted = new javax.swing.JScrollPane();
        jtSorted = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jpBackground.setBackground(new java.awt.Color(240, 240, 0));

        jlblHeader.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jlblHeader.setText("Sorting Efficiencies");

        jLabel1.setText("Amount of numbers to sort:");

        btnGNumber.add(jrbTen);
        jrbTen.setSelected(true);
        jrbTen.setText("10");
        jrbTen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jrbTenActionPerformed(evt);
            }
        });

        btnGNumber.add(jrbTenThousand);
        jrbTenThousand.setText("10000");

        jlblSortingMethod.setText("Display Numbers sorted by:");

        jcbSortingMethod.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Selection Sort", "Inserstion Sort", "Quik Sort" }));
        jcbSortingMethod.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jcbSortingMethodActionPerformed(evt);
            }
        });

        jlblSortOrder.setText("Sort Order");

        btnGOrder.add(jrbAscending);
        jrbAscending.setSelected(true);
        jrbAscending.setText("Ascending");

        btnGOrder.add(jrbDescending);
        jrbDescending.setText("Descending");

        jbSort.setText("Sort");
        jbSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbSortActionPerformed(evt);
            }
        });

        jlblOriginal.setText("Original Numbers: ");

        jtaOriginal.setColumns(20);
        jtaOriginal.setRows(5);
        jScrollPane1.setViewportView(jtaOriginal);

        jlblSorted.setText("Sorted Numbers: ");

        jlblResults.setText("Sort Results");

        jtaResults.setColumns(20);
        jtaResults.setRows(5);
        jScrollPane2.setViewportView(jtaResults);

        jtSorted.setColumns(20);
        jtSorted.setRows(5);
        jtaSorted.setViewportView(jtSorted);

        javax.swing.GroupLayout jpBackgroundLayout = new javax.swing.GroupLayout(jpBackground);
        jpBackground.setLayout(jpBackgroundLayout);
        jpBackgroundLayout.setHorizontalGroup(
            jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpBackgroundLayout.createSequentialGroup()
                .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(jpBackgroundLayout.createSequentialGroup()
                            .addGap(27, 27, 27)
                            .addComponent(jlblHeader, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(jpBackgroundLayout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(jlblSortingMethod)
                            .addGap(18, 18, 18)
                            .addComponent(jcbSortingMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(jpBackgroundLayout.createSequentialGroup()
                            .addContainerGap()
                            .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jpBackgroundLayout.createSequentialGroup()
                                    .addComponent(jlblSortOrder)
                                    .addGap(18, 18, 18)
                                    .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jrbDescending)
                                        .addComponent(jrbAscending))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jbSort, javax.swing.GroupLayout.PREFERRED_SIZE, 142, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jpBackgroundLayout.createSequentialGroup()
                                    .addComponent(jLabel1)
                                    .addGap(18, 18, 18)
                                    .addComponent(jrbTen)
                                    .addGap(18, 18, 18)
                                    .addComponent(jrbTenThousand)))))
                    .addGroup(jpBackgroundLayout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jlblOriginal, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 179, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(93, 93, 93)
                        .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jlblSorted)
                            .addComponent(jtaSorted, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(13, 13, 13)))
                .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jpBackgroundLayout.createSequentialGroup()
                        .addGap(104, 104, 104)
                        .addComponent(jlblResults)
                        .addGap(178, 178, 178))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jpBackgroundLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 296, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())))
        );
        jpBackgroundLayout.setVerticalGroup(
            jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpBackgroundLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jlblHeader, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jrbTen)
                    .addComponent(jrbTenThousand)
                    .addComponent(jlblResults))
                .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jpBackgroundLayout.createSequentialGroup()
                        .addGap(29, 29, 29)
                        .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlblSortingMethod)
                            .addComponent(jcbSortingMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(jpBackgroundLayout.createSequentialGroup()
                                .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jlblSortOrder)
                                    .addComponent(jrbAscending))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jrbDescending))
                            .addComponent(jbSort, javax.swing.GroupLayout.DEFAULT_SIZE, 53, Short.MAX_VALUE))
                        .addGap(19, 19, 19)
                        .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlblOriginal, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jlblSorted))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jpBackgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1)
                            .addComponent(jtaSorted)))
                    .addGroup(jpBackgroundLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 286, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 8, Short.MAX_VALUE)))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jpBackground, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jpBackground, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    
    private int loopCounter = 0 ;//to keep track of the efficiancy of quik sort method
    private DecimalFormat number = new DecimalFormat("#,##0");//instantiate new decimal format object to prevent endless decimals from doubles
    /**
     * This method loads integers from a data file into the array
     *
     * @param nums the array
     */
    private void readFile(int[] nums) {
        try {//try to read from file
            File f;//declare new file
            //use if statments to determine which file to find
            if (jrbTen.isSelected()) {//if the user selected ten
                f = new File("src/wrightsortingefficiencies/10nums.txt");//instatiate new file
            } else {//if the user selected 10000
                f = new File("src/wrightsortingefficiencies/10000nums.txt");//instatiate new file    
            }
            int i = 0 ; //to save the index
            Scanner s = new Scanner(f);//instantiate new scanner
            while (s.hasNextLine()) {//while the scanner has not yet read the entire file
                nums[i] =(Integer.parseInt(s.nextLine()));//add the integer from file into the array
                i += 1 ;//accumulate i
            }
        } catch (FileNotFoundException e) {//catch for file not found exception
            System.out.println(e); //print out error   
        }
    }

    /**
     * This method will return the current time in nanoseconds
     * @return the time in nanoseconds as a double
     */
    public double time(){
        return System.nanoTime() ;//return the time in nanoseconds
    }
    
    
    /**
     * This method will use a quick sort to sort the array 
     *
     * @param list the array 
     * @param left the lowest index value
     * @param right the highest index value
     */
    public void quikSort(int[] list, int left, int right) {
        
        if (left >= right) {//base case check if we are done and return
            return;
        }
        int i = left;//declare int i it will be our dynamic value for the bottom  index
        int j = right;//declare int i it will be our dynamic value for the top  index
        int pivot = list[((left + right) / 2)];//find the middle point
        
        while (i < j) {//while we are not yet done
           
            while (list[i] < pivot) {//ajust i until it is one idex value below pivot
                i++;
                loopCounter += 1 ;//accumulate loop counter
            }
            while (pivot < list[j]) {//ajust j until it is one index value above pivot
                j--;
                loopCounter += 1 ;//accumultae loop counter
            }
            if (i <= j) {//if we need to swap
                
                int temp = list[i];//save the value at i temporarly
                list[i] = list[j];//set the value at i to the value at j
                list[j]=  temp;//set the value at j to the former value of i

                i++;//accumulate i
                j--;//accumulate j
            }
        }
        quikSort(list, left, j);//sort bottom half by invoking method again
        quikSort(list, i, right);//sort above half by invoking method again

    }
    
    /**
     * This method will use a quick sort to sort the array in descending order
     *
     * @param list the array object
     * @param left the lowest index value
     * @param right the highest index value
     */
    public void quikSortDescending(int[] list, int left, int right) {
        
        if (left >= right) {//base case check if we are done and return
            return;
        }
        int i = left;//declare int i it will be our dynamic value for the bottom  index
        int j = right;//declare int i it will be our dynamic value for the top  index
        int pivot = list[((left + right) / 2)];//find the middle point
        while (i < j) {//while we are not yet done
            while (list[i] > pivot) {//ajust i until it is one idex value below pivot (only change from accumulating method is changing to greaterthan sign)
                i++;
                loopCounter += 1 ;//accumulate loop counter
            }
            while (pivot > list[j]) {//ajust j until it is one index value above pivot (only change from accumulating method is changing to greaterthan sign)
                j--;
                loopCounter += 1 ;//accumulate loop counter
            }
            if (i <= j) {//if we need to swap 
                int temp = list[i];//save the value at i temporarly
                list[i] = list[j];//set the value at i to the value at j
                list[j] = temp;//set the value at j to the former value of i

                i++;//accumulate i
                j--;//accumulate j
            }
        }
        quikSortDescending(list, left, j);//sort bottom half by invoking method again
        quikSortDescending(list, i, right);//sort above half by invoking method again

    }

    /**
     * This method will store the array in a string
     *
     * @param list the array
     * @return the String representing the array
     */
    private String printList(int[] list) {
        String toDisplay = "" ;
        for (int i = 0; i < list.length; i++) {//loop through entire array
            toDisplay += i+":  "+list[i] +"\n";//store every integer on a new line of a string variable
        }
        return toDisplay ;
    }

    /**
     * This method uses selection sort to sort an array in ascending order
     *
     * @param list the array
     * @return the number of swaps we have to do
     */
    public int selectionSort(int[] list) {
        int sLoopCounter = 0 ;//number of times we swap
        int numIntegers = list.length;//declare variable to represent size of array list
        int temp;//declare variable to temporarly hold a value in the array list
        for (int i = 0; i < numIntegers; i++) {//use nested for loop to swap entire array list
            for (int j = i + 1; j < numIntegers; j++) {
                sLoopCounter += 1 ;//accumulate loop counter
                if (list[i] > list[j]) {//if we need to swap
                    
                    temp = list[i];//temporarly save the value at i
                    list[i] = list[j];//change the value at i to the value at j
                    list[j] = temp;//change the value at j to the former value of i
                }
            }
        }
        return sLoopCounter ;//return the loop counter
    }
    
    
    
    /**
     * This method uses selection sort to sort an array in descending order
     *
     * @param list the array 
     * @return the loop counter
     */
    public int selectionSortDescending(int[] list) {
        int sLoopCounter = 0 ;//number of times we swap
        int numIntegers = list.length;//declare variable to represent size of array list
        int temp;//declare variable to temporarly hold a value in the array list
        for (int i = 0; i < numIntegers; i++) {//use nested for loop to swap entire array list
            for (int j = i + 1; j < numIntegers; j++) {
                sLoopCounter += 1 ;//accumulate loop counter
                if (list[i] < list[j]) {//if we need to swap (only change from accumulating method is changing to greaterthan sign)
                    
                    temp = list[i];//temporarly save the value at i
                    list[i]= list[j];//change the value at i to the value at j
                    list[j] = temp;//change the value at j to the former value of i
                }
            }
        }
        return sLoopCounter ;//return the loop counter
    }
    
    
    

    /**
     * This method uses insertion sort to sort array in accumulating order
     * @param list the array object
     * @return the loop counter
     */
    public int inscertionSort(int[] list) {
        int sLoopCounter = 0 ;//number of times we swap
        for (int n = 1; n < list.length; n++) {//use for loop to loop through entire array 
            int temp = list[n];//store the value at n temporarely 
            int j = n - 1;//declare variable j which is one before n
            while (j >= 0 && list[j] > temp) {//while we need to move the number down in the 
                sLoopCounter += 1 ;//accumulate loop counter
                list[j + 1] = list[j];//move value one lower in array list
                j = j - 1;//deaccumulate j so we move the value lower in array 
                
            }

            list[j + 1] = temp;//put the number that was replaced in the correct spot
        }
        return sLoopCounter ;//return the loop counter
    }
    
    
    
    /**
     * This method uses insertion sort to sort array in descending order
     * @param list the array object
     * @return the loop counter
     */
    public int inscertionSortDescending(int[] list) {
        int sLoopCounter = 0 ;//number of times we swap
        for (int n = 1; n < list.length; n++) {//use for loop to loop through entire array list
            int temp = list[n];//store the value at n temporarely 
            int j = n - 1;//declare variable j which is one before n
            while (j >= 0 && list[j] < temp) {//while we need to move the number up in the list (changed to lessthan sign)
                sLoopCounter += 1 ;//accumulate loop counter
                list[j + 1] = list[j];//set the value higher in array 
                j = j - 1;//accumulate j so we move the value higher in array each time
                
            }

            list[j + 1]= temp;//put the number that was replaced in the correct spot
        }
        return sLoopCounter ;//return loop counter
    }
    private void jrbTenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jrbTenActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jrbTenActionPerformed

    private void jcbSortingMethodActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jcbSortingMethodActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jcbSortingMethodActionPerformed

    private void jbSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbSortActionPerformed
        // TODO add your handling code here:
        int[] originalList ;
        if (jrbTen.isSelected()) {//if the user selected ten
    originalList = new int[10];//declare new array  
        }else{//if the user selected ten thousand
    originalList = new int[10000];//declare new array          
        }
    readFile(originalList);//use readlist method (the method itself checks for which data file)
    jtaOriginal.setText(printList(originalList));//set the original text area to the original array
    int[] originalList2 = originalList.clone() ;
    int[] originalList3 =  originalList.clone() ;
    loopCounter = 0;//reset loop counter
    int sLoopCounter = 0 ;//initialize variable for efficiancy of selection sort
    int iLoopCounter = 0 ;//initialize variable for efficiancy of inscertion sort
    double selectionStart = 0 ;//variable for the starting time when selection method runs
    double selectionEnd = 0 ;//variable for the finishing time when selection method ends
    double inscertionEnd = 0 ;//variable for the finishing time when inscertion method ends
    double quikEnd = 0 ;//variable for the finishing time when quik method ends
    //use if statment to determine if we need to run the ascending or descending methods
    if(jrbAscending.isSelected()){//is ascending is selected
        //run the ascending methods with the three copies of the array list save efficiancy in loop counter variables
        selectionStart= time();//save time at begining of selection sort
        sLoopCounter =selectionSort(originalList);
        selectionEnd = time();//save time at end of selection sort and begining of incertion sort
        iLoopCounter =inscertionSort(originalList2);
        inscertionEnd = time();//save time at end of inscertion sort and begining of quik sort
        quikSort(originalList3, 0, originalList3.length-1);
        quikEnd = time(); //save time at at end of quik sort
    }else{//is descending is selected
        //run the descending methods with the three copies of the array list save efficiancy in loop counter
        selectionStart= time();//save time at begining of selection sort
        sLoopCounter =selectionSortDescending(originalList);
        selectionEnd = time();//save time at end of selection sort and begining of incertion sort
        iLoopCounter =inscertionSortDescending(originalList2);
        inscertionEnd = time();//save time at end of inscertion sort and begining of quik sort
        quikSortDescending(originalList3, 0, originalList3.length-1);
        quikEnd = time(); //save time at at end of quik sort
    }
    
    //display sorted numbers
    //use if statments to see which sorted array to display
    if(jcbSortingMethod.getSelectedIndex() ==0){//if user selected selection sorting display the array that has been modified by selection sorting
    jtSorted.setText(printList(originalList));
    }else if(jcbSortingMethod.getSelectedIndex() ==1){//if user selected inscertion sorting display the array that has been modified by inscertion sorting
        jtSorted.setText(printList(originalList2));
    }else if(jcbSortingMethod.getSelectedIndex() ==2){//if user selected quik sorting display the array that has been modified by quik sorting
        jtSorted.setText(printList(originalList3));
    }
    
    
    
    //display efficiancy with loop counters and time taken to excecute each method, use our number format to clean the output
    jtaResults.setText("Selection Sort:\nNumber of times the loop was excecuted: "+number.format(sLoopCounter)+"\nNumber of nanoseconds to complete sort: "+ number.format(selectionEnd-selectionStart)
                       +"\nInscertion Sort:\nNumber of times the loop was excecuted: "+number.format(iLoopCounter)+"\nNumber of nanoseconds to complete sort: "+ number.format(inscertionEnd-selectionEnd)
                       +"\nQuik Sort:\nNumber of times the loop was excecuted: "+number.format(loopCounter)+"\nNumber of nanoseconds to complete sort: "+ number.format(quikEnd-inscertionEnd));
    }//GEN-LAST:event_jbSortActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(wrightSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(wrightSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(wrightSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(wrightSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new wrightSortingEfficiencies().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup btnGNumber;
    private javax.swing.ButtonGroup btnGOrder;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton jbSort;
    private javax.swing.JComboBox<String> jcbSortingMethod;
    private javax.swing.JLabel jlblHeader;
    private javax.swing.JLabel jlblOriginal;
    private javax.swing.JLabel jlblResults;
    private javax.swing.JLabel jlblSortOrder;
    private javax.swing.JLabel jlblSorted;
    private javax.swing.JLabel jlblSortingMethod;
    private javax.swing.JPanel jpBackground;
    private javax.swing.JRadioButton jrbAscending;
    private javax.swing.JRadioButton jrbDescending;
    private javax.swing.JRadioButton jrbTen;
    private javax.swing.JRadioButton jrbTenThousand;
    private javax.swing.JTextArea jtSorted;
    private javax.swing.JTextArea jtaOriginal;
    private javax.swing.JTextArea jtaResults;
    private javax.swing.JScrollPane jtaSorted;
    // End of variables declaration//GEN-END:variables
}
